Index: inc/ush.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#ifndef USH_H\n#define USH_H\n\n#include <unistd.h>\n#include <stdlib.h>\n#include <xlocale.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <term.h>\n#include <sys/types.h>\n#include <regex.h> \n#include <pwd.h>\n#include <stdio.h>\n#include <dirent.h>\n#include \"libmx.h\"\n#include <time.h>\n#include <termios.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <termcap.h>\n#include <wchar.h>\n#include <sys/cdefs.h>\n#include <sys/_types.h>\n#include <sys/_types/_pid_t.h>\n#include <sys/_types/_id_t.h>\n#include <sys/signal.h>\n#include <sys/resource.h>\n\n\n#define MX_W_INT(w)         (*(int *)&(w))\n#define MX_WST(x)           (x & 0177)\n#define MX_WIFEXIT(x)       (MX_WST(x) == 0)\n#define MX_WIFSIG(x)        (MX_WST(x) != _WSTOPPED && MX_WST(x) != 0)\n#define MX_WTERMSIG(x)      (MX_WST(x))\n#define MX_EXSTATUS(x)      ((MX_W_INT(x) >> 8) & 0x000000ff)\n\n\n#define MX_STR ush->input->comands[ush->input->id]\n#define MX_COMMAND ush->input->comands\n#define MX_ID ush->input->id\n#define MX_STR_LEN ush->input->str_len\n#define MX_STR_POS ush->input->end_posit\n#define MX_MAX_COMAND ush->input->max_comand\n#define MX_SYMBOL ush->input->if_\n#define MX_ID_TAB_KEY ush->input->pos_tab\n#define MX_FLAGS_W O_RDWR | O_CREAT | O_TRUNC, S_IWRITE | S_IREAD\n#define MX_FLAGS_WE O_RDWR | O_CREAT | O_APPEND, S_IWRITE | S_IREAD\n#define MAX_PROC_COUNT 500\n#define MX_USH \"u$h> \"\n#define MX_SEARCH \"Search > \"\n#define MX_PATH ((t_token*)tmp->next->next->data)->value[0]\n#define MX_FUNC_RETURN mx_return_value(\"HOME\", &(ush->var_tree))\n#define MX_GET_PATH (argv[i] ? argv[i] : MX_FUNC_RETURN)\n#define MX_REG_EXPORT   \"^[A-Za-z_]+[A-Za-z_0-9]*(=.*)?$\"\n#define MX_REG_ERR      \"^^-(i+)?[^Pui]\"\n#define MX_REG_I        \"^-i+((P|u)?|((P|u).+)?)$\"\n#define MX_REG_U        \"^-(i+)?u.*$\"\n#define MX_REG_P        \"^-(i+)?P.*$\"\n#define MX_REG_VER      \"^.+=.*$\"\n#define MX_REG_PROG     \"^[^-]\"\n\n// VARIABLES\n\ntypedef struct s_var {\n    char *name;\n    char *value;\n    bool flag;\n    struct s_var *next;\n}              t_var;\n\ntypedef struct s_variable {\n    char *name;\n    char *value;\n    bool is_env;\n    char *mem;\n}              t_variable;\n\ntypedef struct s_tree_node {\n    struct s_tree_node *left;\n    struct s_tree_node *right;\n    struct s_tree_node *parent;\n    void *data;\n} t_tnode;\n\nenum e_branch {\n    RIGHT,\n    LEFT\n};\n\nenum e_operator_status {\n    OP_NOTHING,\n    OP_PIPE_R,\n    OP_PIPE_W,\n    OP_PIPE_RW,\n    OP_MORE = 4,\n    OP_DMORE = 8,\n    OP_LESS = 16,\n    LEFT_VISITED = 128,\n    RIGHT_VISITED = 64,\n    OP_AMP = 32\n};\n\n// AST\nenum e_type_of_token{\n    TYPE_OPERATOR,\n    TYPE_COMMAND,\n\n    TYPE_FILENAME,\n    TYPE_DESC_NUMB,\n};\n\ntypedef struct s_token{\n    char type;\n    char **value;\n    int priority;\n}              t_token;\n\ntypedef struct s_process {\n    char **name;\n    pid_t pid;\n    int index;\n}              t_process;\n\ntypedef struct s_input {\n    char **comands;\n    char **comand_tab;\n    int id;\n    int max_comand;\n    int str_len;\n    int end_posit;\n    int if_;\n    int pos_tab;\n}              t_input;\n\ntypedef struct s_ush {\n    struct termios term_old;\n    struct termios term_new;\n    char **env;\n    t_list *history;\n    t_input *input;\n    t_list *processes;\n    bool is_exit;\n    bool if_ctrl_c;\n    int exit_status;\n    char *pwd;\n    char *pwd_l;\n    char *pwd_p;\n    char *old_pwd;\n    char *path;\n    char *home;\n    t_list *var_tree;\n    int last_status;\n}              t_ush;\n\nenum e_keys{\n    CTRL_A = 1,\n    CTRL_W = 23,\n    CTRL_E = 5,\n    CTRL_R = 18,\n    CTRL_T = 20,\n    CTRL_Y = 25,\n    CTRL_U = 21,\n    CTRL_I = 9, // TAB\n    CTRL_P = 16,\n    CTRL_CLOSE_BRACKET = 29,\n    CTRL_D = 4,\n    CTRL_F = 6,\n    CTRL_G = 7, // sound\n    CTRL_H = 8,\n    CTRL_K = 11, // vertical tab\n    CTRL_L = 12, // new feed\n    CTRL_Z = 26,\n    CTRL_X = 24,\n    CTRL_C = 3,\n    CTRL_B = 2,\n    CTRL_N = 14,\n    KEY_ESCAPE = 27,\n    KEY_SPACE = 32,\n    KEY_ENTER = 13\n};\n\n\n// tree\nvoid mx_insert_tree(t_tnode **root, t_tnode *new,\n    int (*cmp)(void*, void*),\n    void (*free_)(void *)\n);\n\nt_tnode* mx_get_min_tnode(t_tnode *root);\nvoid mx_strarr_add_to_strarr(char ***strs, char ***str);\nt_tnode *mx_create_tnode(void *data);\nvoid mx_start_program(t_list **var_tree, char **env);\nvoid mx_delete_tnode(t_tnode **root, void *data, int (*cmp)(void*, void*), void (*free_tnode)(t_tnode *tnode));\nvoid mx_push_env(t_list **var_tree, char *name, char *value, char *mem);\nt_tnode *mx_find_tnode(t_tnode *root, void *data, int (*cmp)(void*, void*));\nvoid mx_if_new_parameter(char *str, int *start, int end, t_ush *processes);\nchar *mx_return_value(char **str, t_list **var_tree);\nchar *mx_return_value2(const char *str, t_list **var_tree);\nvoid mx_serch_list(t_list **var_tree, char *name, char *value);\nt_token *mx_create_token(char type, char **value, int priority);\nvoid mx_clear_tokens(t_list **tokens);\nt_token* mx_get_next_token(int *start, int end, char *str, t_ush *processes);\nchar mx_get_token_type(char *str);\nvoid mx_parametr_shell(t_ush *processes, int *i, char **new_str);\nint mx_flang_comand(char *str, int *pos, int end, int flag);\nvoid mx_read_user(char **user);\nt_token *mx_token_in_program(int *curr_pos, int end, char *str, t_ush *processes);\nint mx_exec_dmore(t_tnode *root, int *fds, int operatorStatus, t_ush *ush);\nvoid mx_ush_init(t_ush **ush, char **env);\nvoid mx_subs(char **str);\nvoid mx_parsing(char *str, t_ush *ush);\nt_list *mx_lexer(char *str, t_ush *processes);\nbool mx_syntax_analyzer(t_list *tokens);\nvoid mx_execute(char **commands, t_ush *processes);\nvoid mx_ush_close(t_ush *ush);\nvoid mx_charge_parametr_export(char *value, char *tmp, t_variable *data);\n\nvoid mx_write_from_to(int from , int to, off_t start);\n// typedef struct termios t_termios;\n\n//BUILT IN\nint mx_cd(char **argv, t_ush *ush);\nint mx_history(t_list **list_comands);\nvoid mx_printstr_env(char *str);\nint mx_pwd(char **argv, t_ush *ush);\nvoid mx_echo(char **str,  t_ush *ush);\nvoid mx_env(char **argv, t_ush *ush);\nvoid mx_export(char **argv, t_list **var_tree, t_ush *ush);\nvoid mx_unset(char **argv, t_list **var_tree, t_ush *ush);\nvoid mx_which(char **argv, t_ush *ush);\nbool mx_is_buildin(char *str);\nvoid mx_jobs(t_ush *ush);\nvoid mx_fg(char **argv, t_ush *ush);\nvoid mx_exit(t_token *token, t_ush *ush);\n\n//CD \nint mx_chdir_p(char *path, t_ush *ush, char flags);\nchar* mx_add_one_rank(char *path, char *new_part);\nchar* mx_del_last_rank(char *path);\nint mx_chdir_l(char *path, t_ush *ush, char flags);\n\n// Which\nbool mx_is_commad(char *fullname, int flags);\n\n//\nbool mx_check_symbol(char *str, int position, char symbol);\nvoid mx_ctrl_v_and_not_ascii(t_ush *ush, char *chars);\nvoid mx_ctrl_r(t_ush *ush);\nint mx_ascii(t_ush *ush, char *chars, unsigned int ch);\nint mx_end_flag(char *str, int *position, int end, int flag);\nchar *mx_parsing_input(char *str);\nchar *mx_audit_str(char *str, t_ush *processes, bool dqute);\nchar *mx_str_bquote(char **str, t_ush *processes);\nchar **mx_create_comands(char *str, int end);\nvoid mx_one_symbol(char **str, char ch, int *count, int position);\nvoid mx_not_ascii(char *chars, t_ush *ush);\nint mx_bit_sumbol(char *str);\nint mx_len_symbol(int sum, char *str);\nint mx_input(t_ush *ush);\nvoid mx_print_esc(char *s);\nvoid mx_check_outprogram_new_line(void);\nvoid mx_clean_space_in_term(char *str, t_ush *ush, char *new_str);\nvoid mx_print_esc(char *s);\nvoid mx_terminal_out(char *name, int table2, int pos,char *str);\nvoid mx_clean_terminal(char *name, int table2, int pos,char *str);\nvoid mx_print_esc(char *s);\nvoid mx_key_delite(t_ush *ush);\nchar **mx_key_tab(char *parsing, char **str, t_ush *ush);\nchar *mx_mini_parser_tab(char *parsing, t_ush *ush);\nvoid mx_read_comand(char *parsing, t_list **list_comand);\nvoid mx_key_duble_tab(char **str, char **comands, t_ush *ush);\nvoid mx_print_tab_comands(t_list *list_comand);\nt_ush* mx_get_info(t_ush *ush);\nbool mx_is_link(char *file);\nvoid mx_unset_fds(int *fds, int *savedFds, int operator_starus);\nt_var *mx_var_tree_to_var(t_list *var_tree);\nint mx_get_twidth();\n\n// lexer\nbool mx_is_char(char c);\nvoid mx_home(char **str, int *i, t_ush *processes);\nvoid mx_do_replace(char **str, size_t start, size_t end, char *str_new);\nbool mx_is_operator(t_token *token);\nunsigned int mx_read_keyboard(t_ush *ush);\n\n// AST\nt_tnode* mx_create_ast(t_list** tokens, t_tnode *prev);\nvoid mx_delete_ast(t_tnode **root);\n\n//exec\nint mx_execute_tree(t_tnode *root, int *fds, char operator_status, t_ush *ush);\nint mx_exec_more(t_tnode *root, int *fds, int operator_status, t_ush *ush);\nint exec_token(t_token *token, int *fds, char operator_status, t_ush *ush);\nvoid mx_exec_less(t_tnode *root, int *fds, char operator_status, t_ush *ush);\nvoid mx_execute_proces(t_token* token);\nvoid mx_close_all_pr(t_ush *ush);\nint mx_pipe_execute(t_tnode *root, int *fds, char operator_status, t_ush *processes);\nint mx_buildin_list(t_token *token, t_ush *ush);\nvoid mx_exec_env_pr(char *path, char **argv, char **env, t_ush *ush);\n\n// processes\nint mx_add_process(t_list **processes, pid_t pid, char **name);\nvoid mx_del_top_process(t_ush *ush);\nvoid mx_del_pid_process(t_ush *ush, int pid);\nvoid mx_wait_process(t_ush *ush, char **argv);\nvoid mx_segfault();\nvoid mx_ctrl_c();\nvoid mx_ctrl_z();\nvoid mx_segfault_in();\nvoid mx_loop(char str, t_ush *ush);\n\n//print\nvoid mx_print_susp(char **mas_name);\nvoid mx_print_cont(char **mas_name, int pid);\nchar **mx_get_name(t_ush *ush, int numb);\n\n// env \n\nchar **mx_call_vlad(char **argv, int i);\nchar **mx_env_to_vlad(t_var *var);\nbool mx_check_env(char **argv, char **path, t_var *var, int *i);\nbool mx_printerr_env(char *str, int flag);\nvoid mx_print_env(t_var *var);\nvoid mx_fre_env_path(t_var *var, char *path);\nbool mx_reg(char *str, char *regular);\nchar *mx_get_path_env(char *str1, char *str2, int *i);\nint mx_delete_veriable_env(char *str1, char *str2, t_var *var, int *i);\n\n// echo\nint mx_0_and_x(char *str, int *i);\n\n//utils\nchar *mx_strjoin2(char *s1, char *s2);\nchar **mx_dupstrarr(char **strs);\nint mx_strcmp2(const char *s1, const char *s2);\nchar *mx_strjoin3(char *s1, char *s2);\nchar *mx_arrstr_to_str(char **strs);\nunsigned int mx_getchar();\nbool mx_is_str_starts(char *string, char *start);\nvoid mx_add_to_strarr(char ***strs, char *str);\nvoid mx_pop_front_free_data(t_list **head);\nvoid mx_pop_list(t_list **head, void *data, bool(*if_list)(void *, void *),\n                 void(*del_data)(void *));\n\n\n#endif\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- inc/ush.h	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ inc/ush.h	(date 1592819111000)
@@ -36,19 +36,10 @@
 #define MX_WTERMSIG(x)      (MX_WST(x))
 #define MX_EXSTATUS(x)      ((MX_W_INT(x) >> 8) & 0x000000ff)
 
-
-#define MX_STR ush->input->comands[ush->input->id]
-#define MX_COMMAND ush->input->comands
-#define MX_ID ush->input->id
-#define MX_STR_LEN ush->input->str_len
-#define MX_STR_POS ush->input->end_posit
-#define MX_MAX_COMAND ush->input->max_comand
-#define MX_SYMBOL ush->input->if_
-#define MX_ID_TAB_KEY ush->input->pos_tab
 #define MX_FLAGS_W O_RDWR | O_CREAT | O_TRUNC, S_IWRITE | S_IREAD
 #define MX_FLAGS_WE O_RDWR | O_CREAT | O_APPEND, S_IWRITE | S_IREAD
 #define MAX_PROC_COUNT 500
-#define MX_USH "u$h> "
+#define MX_USH "\032u$h> \x1b[32;5;68m"
 #define MX_SEARCH "Search > "
 #define MX_PATH ((t_token*)tmp->next->next->data)->value[0]
 #define MX_FUNC_RETURN mx_return_value("HOME", &(ush->var_tree))
@@ -117,21 +108,21 @@
     int priority;
 }              t_token;
 
-typedef struct s_process {
+typedef struct s_processes {
     char **name;
     pid_t pid;
     int index;
-}              t_process;
+}              t_processes;
 
 typedef struct s_input {
     char **comands;
     char **comand_tab;
     int id;
-    int max_comand;
-    int str_len;
-    int end_posit;
-    int if_;
-    int pos_tab;
+    int fullcom;
+    int inplen;
+    int endpoint;
+    int symbol;
+    int tab_key;
 }              t_input;
 
 typedef struct s_ush {
Index: src/utils/mx_loop.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nvoid mx_loop(char str, t_ush *ush) {\n     while (str != 0) {\n         if (ush->history && str == 1) {\n             mx_parsing(ush->history->data, ush);\n             mx_check_outprogram_new_line();\n         }\n         if (ush->is_exit)\n             break;\n         str = mx_input(ush);\n         ush->if_ctrl_c = 1;\n     }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/utils/mx_loop.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/utils/mx_loop.c	(date 1592818207000)
@@ -1,7 +1,7 @@
 #include "ush.h"
 
 void mx_loop(char str, t_ush *ush) {
-     while (str != 0) {
+     while (str) {
          if (ush->history && str == 1) {
              mx_parsing(ush->history->data, ush);
              mx_check_outprogram_new_line();
Index: src/utils/mx_term_out.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nvoid mx_check_outprogram_new_line(void) {\n    int twidth = mx_get_twidth() - 1;\n    int save_fd1 = dup(1);\n    int term_fd1 = open(\"/dev/tty\", O_WRONLY);\n\n    dup2(term_fd1, 1);\n    write(1,\"%\",1);\n    for (int i = 0; i < twidth; i++)\n        write(1,\" \",1);\n    write(1,\"\\r\",1);\n    mx_print_esc(\"J\");\n    dup2(save_fd1, 1);\n    close(save_fd1);\n    close(term_fd1);\n}\n\nstatic void print_two_str(char *str1, char *str2) {\n    mx_printstr(str1);\n    mx_printstr(str2);\n}\n\nvoid mx_terminal_out(char *name, int table2, int pos, char *str) {\n    int symbol = mx_bit_sumbol(&str[table2 - pos - 1]);\n    int len = (int) name[0];\n    int col = mx_get_twidth();\n\n    print_two_str(&name[1], str);\n    mx_printstr(\" \");\n    for (int i = (mx_len_symbol(table2, str) + len) / col; i > 0; i--)\n        mx_print_esc(\"1F\");\n    write(1,\"\\r\",1);\n    mx_printstr(&name[1]);\n    write(1, str, table2 - pos - 1);\n    if ((mx_len_symbol(table2 - pos, str) + len) % col == 0) {\n        if (pos == 0)\n            write(1, \" \", 1);\n        else\n            write(1, &str[table2 - pos - 1], symbol);\n        write(1, \"\\b\", 1);\n    }\n    mx_printstr(\"\\x1b[0m\");\n}\n\nvoid mx_clean_terminal(char *name, int table2, int pos, char *str) {\n\n    int temp;\n    int len = (int)name[0];\n\n    temp = (mx_len_symbol(table2 - pos, str) + len) / mx_get_twidth();\n    for (int i = temp; i > 0; i--) {\n        mx_print_esc(\"1F\");\n    }\n    write(1,\"\\r\",1);\n    mx_print_esc(\"J\");\n}\n\nvoid mx_clean_space_in_term(char *str, t_ush *ush, char *new_str) {\n    int temp;\n    int col = mx_get_twidth();\n\n    temp = (mx_len_symbol(MX_STR_LEN - MX_STR_POS, str) + 4) / col;\n    for (int i = temp; i > 0; i--) {\n        mx_print_esc(\"1F\");\n    }\n    write(1,\"\\r\",1);\n    mx_print_esc(\"J\");\n    mx_printstr(MX_USH);\n    mx_printstr(new_str);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/utils/mx_term_out.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/utils/mx_term_out.c	(date 1592819079000)
@@ -40,7 +40,7 @@
             write(1, &str[table2 - pos - 1], symbol);
         write(1, "\b", 1);
     }
-    mx_printstr("\x1b[0m");
+    //mx_printstr("\x1b[0m");
 }
 
 void mx_clean_terminal(char *name, int table2, int pos, char *str) {
@@ -60,7 +60,7 @@
     int temp;
     int col = mx_get_twidth();
 
-    temp = (mx_len_symbol(MX_STR_LEN - MX_STR_POS, str) + 4) / col;
+    temp = (mx_len_symbol(ush->input->inplen - ush->input->endpoint, str) + 4) / col;
     for (int i = temp; i > 0; i--) {
         mx_print_esc("1F");
     }
Index: src/utils/mx_input.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nstatic char **creat_comands(t_list **list_comands) {\n    int sum_comand = mx_list_size(*list_comands) + 2;\n    char **comands = (char **) malloc(sum_comand * sizeof(char *));\n    t_list *list = *list_comands;\n\n    comands[0] = mx_strnew(0);\n    comands[1] = NULL;\n    for (int i = 1; list != 0; i++) {\n        comands[i] = mx_strdup(list->data);\n        list = list->next;\n        comands[i + 1] = NULL;\n    }\n    return comands;\n}\n\nstatic t_input *create_input(t_ush *ush) {\n    t_input *input = (t_input *) malloc(sizeof(t_input));\n\n    input->comands = creat_comands(&(ush->history));\n    input->id = 0;\n    input->max_comand = mx_list_size(ush->history);\n    input->str_len = 1;\n    input->pos_tab = 0;\n    input->end_posit = 0;\n    input->if_ = 0;\n    return input;\n}\n\nstatic void del_input(t_ush *ush) {\n    t_input *input = ush->input;\n\n    mx_del_strarr(&(input->comands));\n    free(input);\n    ush->input = 0;\n}\n\nstatic void return_descriptors(int fd1, int fd2, t_ush *ush) {\n    del_input(ush);\n    dup2(fd1, 1);\n    close(fd1);\n    close(fd2);\n}\n\nint mx_input(t_ush *ush) {\n    unsigned int ch = 0;\n    char *chars = (char*)(&ch);\n    int if_next = 3;\n    int save_fd1 = dup(1);\n    int term_fd1 = open(\"/dev/tty\", O_WRONLY);\n\n    dup2(term_fd1, 1);\n    ush->input = create_input(ush);\n    while (if_next == 3) {\n        if (chars[2] != 10 || chars[0] == 9 || chars[0] == 18)\n            mx_terminal_out(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);\n        ch = mx_read_keyboard(ush);\n        if (ch > 127)\n            mx_ctrl_v_and_not_ascii(ush, chars);\n        else\n            if_next = mx_ascii(ush, chars, ch);\n        ush->input->if_ = chars[0];\n    }\n    return_descriptors(save_fd1, term_fd1, ush);\n    return if_next;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/utils/mx_input.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/utils/mx_input.c	(date 1592818286000)
@@ -20,11 +20,11 @@
 
     input->comands = creat_comands(&(ush->history));
     input->id = 0;
-    input->max_comand = mx_list_size(ush->history);
-    input->str_len = 1;
-    input->pos_tab = 0;
-    input->end_posit = 0;
-    input->if_ = 0;
+    input->fullcom = mx_list_size(ush->history);
+    input->inplen = 1;
+    input->tab_key = 0;
+    input->endpoint = 0;
+    input->symbol = 0;
     return input;
 }
 
@@ -54,13 +54,14 @@
     ush->input = create_input(ush);
     while (if_next == 3) {
         if (chars[2] != 10 || chars[0] == 9 || chars[0] == 18)
-            mx_terminal_out(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);
+            mx_terminal_out(MX_USH, ush->input->inplen, ush->input->endpoint,
+                            ush->input->comands[ush->input->id]);
         ch = mx_read_keyboard(ush);
         if (ch > 127)
             mx_ctrl_v_and_not_ascii(ush, chars);
         else
             if_next = mx_ascii(ush, chars, ch);
-        ush->input->if_ = chars[0];
+        ush->input->symbol = chars[0];
     }
     return_descriptors(save_fd1, term_fd1, ush);
     return if_next;
Index: src/utils/mx_ascii.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nstatic int mx_handle_events(char ch) {\n    if (ch == KEY_ENTER) {\n        return KEY_ENTER;\n    }\n    if (ch == CTRL_I)\n        return 9;\n    if (ch == CTRL_D) {\n        return -1;\n    }\n    if (ch == CTRL_Z) {\n        write(1, \"\\a\", 1);\n    }\n    if (ch == CTRL_C)\n        return 2;\n    if (ch == CTRL_R)\n        return 18;\n    return 0;\n}\n\nstatic void special_symbols(unsigned int ch, t_ush *ush) {\n    int str_pos = MX_STR_LEN - MX_STR_POS - 1;\n    char *str_tab = 0;\n\n    if (MX_SYMBOL != 9 && ch == 9) {\n        str_tab = mx_strndup(MX_STR,str_pos);\n        mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);\n        ush->input->comand_tab = mx_key_tab(str_tab, &MX_STR, ush);\n        ush->input->pos_tab = 0;\n    }\n    if (MX_SYMBOL == 9 && ch == 9) {\n        mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);\n        mx_key_duble_tab(&MX_STR, ush->input->comand_tab, ush);\n    }\n    MX_SYMBOL = mx_handle_events(ch);\n    if (MX_SYMBOL == 18) {\n        mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);\n        mx_ctrl_r(ush);\n    }\n}\n\nstatic int ctrl_enter_d_c(t_ush *ush) {\n    if (MX_SYMBOL == -1) {\n        mx_clean_space_in_term(MX_STR, ush, \"exit\");\n        return 0;\n    }\n    else if (MX_SYMBOL == 2) {\n        mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);\n        return 2;\n    }\n    else if (MX_SYMBOL == KEY_ENTER) {\n        mx_clean_space_in_term(MX_STR, ush, MX_STR);\n        if (mx_strlen(MX_STR) != 0) {\n            if (ush->history == NULL\n                || mx_strcmp(MX_STR, ush->history->data) != 0)\n                mx_push_front(&ush->history, mx_strdup(MX_STR));\n            return 1;\n        }\n    }\n    return 3;\n}\n\nint mx_ascii(t_ush *ush, char *chars, unsigned int ch) {\n    int spec_symbol = 3;\n\n    if (ch < 32) {\n        special_symbols(ch, ush);\n        if (MX_SYMBOL == -1 || MX_SYMBOL == 2 || MX_SYMBOL == 13)\n            spec_symbol = ctrl_enter_d_c(ush);\n        else\n            chars[2] = 10;\n    }\n    else {\n        mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);\n        mx_one_symbol(&(MX_STR), ch, &(MX_STR_LEN), MX_STR_POS);\n    }\n    return spec_symbol;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/utils/mx_ascii.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/utils/mx_ascii.c	(date 1592817913000)
@@ -20,41 +20,41 @@
 }
 
 static void special_symbols(unsigned int ch, t_ush *ush) {
-    int str_pos = MX_STR_LEN - MX_STR_POS - 1;
+    int str_pos = ush->input->inplen - ush->input->endpoint - 1;
     char *str_tab = 0;
 
-    if (MX_SYMBOL != 9 && ch == 9) {
-        str_tab = mx_strndup(MX_STR,str_pos);
-        mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);
-        ush->input->comand_tab = mx_key_tab(str_tab, &MX_STR, ush);
-        ush->input->pos_tab = 0;
+    if (ush->input->symbol != 9 && ch == 9) {
+        str_tab = mx_strndup(ush->input->comands[ush->input->id],str_pos);
+        mx_clean_terminal(MX_USH, ush->input->inplen, ush->input->endpoint, ush->input->comands[ush->input->id]);
+        ush->input->comand_tab = mx_key_tab(str_tab, &ush->input->comands[ush->input->id], ush);
+        ush->input->tab_key = 0;
     }
-    if (MX_SYMBOL == 9 && ch == 9) {
-        mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);
-        mx_key_duble_tab(&MX_STR, ush->input->comand_tab, ush);
+    if (ush->input->symbol == 9 && ch == 9) {
+        mx_clean_terminal(MX_USH, ush->input->inplen, ush->input->endpoint, ush->input->comands[ush->input->id]);
+        mx_key_duble_tab(&ush->input->comands[ush->input->id], ush->input->comand_tab, ush);
     }
-    MX_SYMBOL = mx_handle_events(ch);
-    if (MX_SYMBOL == 18) {
-        mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);
+    ush->input->symbol = mx_handle_events(ch);
+    if (ush->input->symbol == 18) {
+        mx_clean_terminal(MX_USH, ush->input->inplen, ush->input->endpoint, ush->input->comands[ush->input->id]);
         mx_ctrl_r(ush);
     }
 }
 
 static int ctrl_enter_d_c(t_ush *ush) {
-    if (MX_SYMBOL == -1) {
-        mx_clean_space_in_term(MX_STR, ush, "exit");
+    if (ush->input->symbol == -1) {
+        mx_clean_space_in_term(ush->input->comands[ush->input->id], ush, "exit");
         return 0;
     }
-    else if (MX_SYMBOL == 2) {
-        mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);
+    else if (ush->input->symbol == 2) {
+        mx_clean_terminal(MX_USH, ush->input->inplen, ush->input->endpoint, ush->input->comands[ush->input->id]);
         return 2;
     }
-    else if (MX_SYMBOL == KEY_ENTER) {
-        mx_clean_space_in_term(MX_STR, ush, MX_STR);
-        if (mx_strlen(MX_STR) != 0) {
+    else if (ush->input->symbol == KEY_ENTER) {
+        mx_clean_space_in_term(ush->input->comands[ush->input->id], ush, ush->input->comands[ush->input->id]);
+        if (mx_strlen(ush->input->comands[ush->input->id]) != 0) {
             if (ush->history == NULL
-                || mx_strcmp(MX_STR, ush->history->data) != 0)
-                mx_push_front(&ush->history, mx_strdup(MX_STR));
+                || mx_strcmp(ush->input->comands[ush->input->id], ush->history->data) != 0)
+                mx_push_front(&ush->history, mx_strdup(ush->input->comands[ush->input->id]));
             return 1;
         }
     }
@@ -66,14 +66,14 @@
 
     if (ch < 32) {
         special_symbols(ch, ush);
-        if (MX_SYMBOL == -1 || MX_SYMBOL == 2 || MX_SYMBOL == 13)
+        if (ush->input->symbol == -1 || ush->input->symbol == 2 || ush->input->symbol == 13)
             spec_symbol = ctrl_enter_d_c(ush);
         else
             chars[2] = 10;
     }
     else {
-        mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);
-        mx_one_symbol(&(MX_STR), ch, &(MX_STR_LEN), MX_STR_POS);
+        mx_clean_terminal(MX_USH, ush->input->inplen, ush->input->endpoint, ush->input->comands[ush->input->id]);
+        mx_one_symbol(&(ush->input->comands[ush->input->id]), ch, &(ush->input->inplen), ush->input->endpoint);
     }
     return spec_symbol;
 }
Index: src/builtins/mx_del_top_process.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nvoid mx_del_top_process(t_ush *ush) {\n    if (!ush->processes)\n        return;\n    mx_del_strarr(&((t_process*)ush->processes->data)->name);\n    mx_pop_front(&ush->processes);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/builtins/mx_del_top_process.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/builtins/mx_del_top_process.c	(date 1592817913000)
@@ -3,6 +3,6 @@
 void mx_del_top_process(t_ush *ush) {
     if (!ush->processes)
         return;
-    mx_del_strarr(&((t_process*)ush->processes->data)->name);
+    mx_del_strarr(&((t_processes*)ush->processes->data)->name);
     mx_pop_front(&ush->processes);
 }
Index: src/builtins/mx_get_name.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nchar **mx_get_name(t_ush *ush, int numb) {\n    t_list *head_pr = ush->processes;\n\n    while (head_pr) {\n        if (((t_process*)head_pr->data)->pid == numb) {\n            return ((t_process*)head_pr->data)->name;\n        }\n        head_pr = head_pr->next;\n    }\n    return 0;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/builtins/mx_get_name.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/builtins/mx_get_name.c	(date 1592817913000)
@@ -4,8 +4,8 @@
     t_list *head_pr = ush->processes;
 
     while (head_pr) {
-        if (((t_process*)head_pr->data)->pid == numb) {
-            return ((t_process*)head_pr->data)->name;
+        if (((t_processes*)head_pr->data)->pid == numb) {
+            return ((t_processes*)head_pr->data)->name;
         }
         head_pr = head_pr->next;
     }
Index: src/parsers/mx_key_delite.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nvoid mx_key_delite(t_ush *ush) {\n    int i;\n    int sum = mx_bit_sumbol(&MX_STR[MX_STR_LEN - MX_STR_POS - 1]);\n\n    mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);\n    for (;sum > 0; sum--) {\n        i = MX_STR_POS;\n        MX_STR_POS--;\n        while (i > 0) {\n            MX_STR[MX_STR_LEN - i - 1] = MX_STR[MX_STR_LEN - i];\n            i--;\n        }\n        MX_STR_LEN--;\n    }\n    ush->input->comands[MX_MAX_COMAND][MX_STR_LEN - 1] = 0;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/parsers/mx_key_delite.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/parsers/mx_key_delite.c	(date 1592817913000)
@@ -2,17 +2,17 @@
 
 void mx_key_delite(t_ush *ush) {
     int i;
-    int sum = mx_bit_sumbol(&MX_STR[MX_STR_LEN - MX_STR_POS - 1]);
+    int sum = mx_bit_sumbol(&ush->input->comands[ush->input->id][ush->input->inplen - ush->input->endpoint - 1]);
 
-    mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);
+    mx_clean_terminal(MX_USH, ush->input->inplen, ush->input->endpoint, ush->input->comands[ush->input->id]);
     for (;sum > 0; sum--) {
-        i = MX_STR_POS;
-        MX_STR_POS--;
+        i = ush->input->endpoint;
+        ush->input->endpoint--;
         while (i > 0) {
-            MX_STR[MX_STR_LEN - i - 1] = MX_STR[MX_STR_LEN - i];
+            ush->input->comands[ush->input->id][ush->input->inplen - i - 1] = ush->input->comands[ush->input->id][ush->input->inplen - i];
             i--;
         }
-        MX_STR_LEN--;
+        ush->input->inplen--;
     }
-    ush->input->comands[MX_MAX_COMAND][MX_STR_LEN - 1] = 0;
+    ush->input->comands[ush->input->fullcom][ush->input->inplen - 1] = 0;
 }
Index: src/builtins/mx_del_pid_process.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nvoid mx_del_pid_process(t_ush *ush, int pid) {\n    t_list *tmp = ush->processes;\n    t_list *tmp2 = ush->processes;\n\n    if (ush->processes) {\n        if (((t_process*)tmp->data)->pid == pid) {\n            mx_del_top_process(ush);\n            return;\n        }\n        while (tmp->next) {\n            if (((t_process*)tmp->next->data)->pid == pid) {\n                tmp2 = tmp->next;\n                tmp->next = tmp->next->next;\n                mx_del_strarr(&((t_process*)tmp2->data)->name);\n                free(tmp2->data);\n                free(tmp2);\n                return;\n            }\n            tmp = tmp->next;\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/builtins/mx_del_pid_process.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/builtins/mx_del_pid_process.c	(date 1592817913000)
@@ -5,15 +5,15 @@
     t_list *tmp2 = ush->processes;
 
     if (ush->processes) {
-        if (((t_process*)tmp->data)->pid == pid) {
+        if (((t_processes*)tmp->data)->pid == pid) {
             mx_del_top_process(ush);
             return;
         }
         while (tmp->next) {
-            if (((t_process*)tmp->next->data)->pid == pid) {
+            if (((t_processes*)tmp->next->data)->pid == pid) {
                 tmp2 = tmp->next;
                 tmp->next = tmp->next->next;
-                mx_del_strarr(&((t_process*)tmp2->data)->name);
+                mx_del_strarr(&((t_processes*)tmp2->data)->name);
                 free(tmp2->data);
                 free(tmp2);
                 return;
Index: src/builtins/mx_key_duble_tab.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nstatic void not_id_0(char **str, char **comands, t_ush *ush) {\n    for (int i = 0; comands[MX_ID_TAB_KEY - 1][i]; i++)\n        mx_one_symbol(str, 127, &(MX_STR_LEN), MX_STR_POS);\n    if (comands[MX_ID_TAB_KEY] != 0) {\n        for (int i = 0; comands[MX_ID_TAB_KEY][i]; i++)\n            mx_one_symbol(str, comands[MX_ID_TAB_KEY][i],\n                          &(MX_STR_LEN), MX_STR_POS);\n        MX_ID_TAB_KEY++;\n    }\n    else {\n        for (int i = 0; comands[0][i]; i++)\n            mx_one_symbol(str, comands[0][i], &(MX_STR_LEN), MX_STR_POS);\n        MX_ID_TAB_KEY = 1;\n    }\n}\n\nvoid mx_key_duble_tab(char **str, char **comands, t_ush *ush) {\n    if (comands != 0 && comands[0] != 0) {\n        if (MX_ID_TAB_KEY == 0 && comands[0] != 0) {\n            for (int i = 0; comands[0][i]; i++)\n                mx_one_symbol(str, comands[0][i], &(MX_STR_LEN), MX_STR_POS);\n            if (MX_STR_POS != 0) {\n                mx_one_symbol(str, ' ', &(MX_STR_LEN), MX_STR_POS);\n                MX_STR_POS++;\n            }\n            MX_ID_TAB_KEY++;\n        }\n        else\n            not_id_0(str,comands, ush);\n    }\n    else\n        write(1,\"\\a\", 1);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/builtins/mx_key_duble_tab.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/builtins/mx_key_duble_tab.c	(date 1592817913000)
@@ -1,31 +1,31 @@
 #include "ush.h"
 
 static void not_id_0(char **str, char **comands, t_ush *ush) {
-    for (int i = 0; comands[MX_ID_TAB_KEY - 1][i]; i++)
-        mx_one_symbol(str, 127, &(MX_STR_LEN), MX_STR_POS);
-    if (comands[MX_ID_TAB_KEY] != 0) {
-        for (int i = 0; comands[MX_ID_TAB_KEY][i]; i++)
-            mx_one_symbol(str, comands[MX_ID_TAB_KEY][i],
-                          &(MX_STR_LEN), MX_STR_POS);
-        MX_ID_TAB_KEY++;
+    for (int i = 0; comands[ush->input->tab_key - 1][i]; i++)
+        mx_one_symbol(str, 127, &(ush->input->inplen), ush->input->endpoint);
+    if (comands[ush->input->tab_key] != 0) {
+        for (int i = 0; comands[ush->input->tab_key][i]; i++)
+            mx_one_symbol(str, comands[ush->input->tab_key][i],
+                          &(ush->input->inplen), ush->input->endpoint);
+        ush->input->tab_key++;
     }
     else {
         for (int i = 0; comands[0][i]; i++)
-            mx_one_symbol(str, comands[0][i], &(MX_STR_LEN), MX_STR_POS);
-        MX_ID_TAB_KEY = 1;
+            mx_one_symbol(str, comands[0][i], &(ush->input->inplen), ush->input->endpoint);
+        ush->input->tab_key = 1;
     }
 }
 
 void mx_key_duble_tab(char **str, char **comands, t_ush *ush) {
     if (comands != 0 && comands[0] != 0) {
-        if (MX_ID_TAB_KEY == 0 && comands[0] != 0) {
+        if (ush->input->tab_key == 0 && comands[0] != 0) {
             for (int i = 0; comands[0][i]; i++)
-                mx_one_symbol(str, comands[0][i], &(MX_STR_LEN), MX_STR_POS);
-            if (MX_STR_POS != 0) {
-                mx_one_symbol(str, ' ', &(MX_STR_LEN), MX_STR_POS);
-                MX_STR_POS++;
+                mx_one_symbol(str, comands[0][i], &(ush->input->inplen), ush->input->endpoint);
+            if (ush->input->endpoint != 0) {
+                mx_one_symbol(str, ' ', &(ush->input->inplen), ush->input->endpoint);
+                ush->input->endpoint++;
             }
-            MX_ID_TAB_KEY++;
+            ush->input->tab_key++;
         }
         else
             not_id_0(str,comands, ush);
Index: src/builtins/mx_ctrl_v_and_not_ascii.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nvoid mx_ctrl_v_and_not_ascii(t_ush *ush, char *chars) {\n    if (chars[0] == 27)\n        mx_not_ascii(chars, ush);\n    else {\n        mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);\n        for (int i = 0; i < 4 && chars[i] != 0; i++)\n            mx_one_symbol(&(MX_STR), chars[i], &(MX_STR_LEN), MX_STR_POS);\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/builtins/mx_ctrl_v_and_not_ascii.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/builtins/mx_ctrl_v_and_not_ascii.c	(date 1592817913000)
@@ -4,8 +4,8 @@
     if (chars[0] == 27)
         mx_not_ascii(chars, ush);
     else {
-        mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);
+        mx_clean_terminal(MX_USH, ush->input->inplen, ush->input->endpoint, ush->input->comands[ush->input->id]);
         for (int i = 0; i < 4 && chars[i] != 0; i++)
-            mx_one_symbol(&(MX_STR), chars[i], &(MX_STR_LEN), MX_STR_POS);
+            mx_one_symbol(&(ush->input->comands[ush->input->id]), chars[i], &(ush->input->inplen), ush->input->endpoint);
     }
 }
Index: src/builtins/mx_fg.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nstatic t_process* get_process(int n, char *str, t_ush *ush) {\n    t_list *tmp = ush->processes;\n\n    if (n != -1) {\n        while (tmp) {\n            if (((t_process*)tmp->data)->index == n)\n                return ((t_process*)tmp->data);\n            tmp = tmp->next;\n        }\n        fprintf(stderr, \"fg: job not found: %s\\n\", str);\n    }\n    else {\n        while (tmp) {\n            if (mx_is_str_starts(((t_process*)tmp->data)->name[0], str))\n                return ((t_process*)tmp->data);\n            tmp = tmp->next;\n        }\n        fprintf(stderr, \"fg: job not found: %s\\n\", str);\n    }\n    return 0;\n}\n\n/*return true if all elements - numbers*/\nstatic bool mx_is_number_fg(char *str) {\n    int i = -1;\n    if (str[0] == '%')\n        i++;\n    while (str[++i]) {\n        if (str[i] < 48 || str[i] > 57)\n            return false;\n    }\n    return true;\n}\n\nstatic int fg_continue(char **argv, t_ush *ush) {\n    t_process *pr = (t_process*)ush->processes->data;\n    int i = 0;\n\n    if (argv[1] == 0) {\n        kill(pr->pid, SIGCONT);\n        return 0;\n    }\n    i = (argv[1][0] == '%') ? 1 : 0;\n    if (mx_is_number_fg(argv[1])) {\n            pr = get_process(atoi(&argv[1][i]), argv[1], ush);\n    }\n    else {\n        pr = get_process(-1, &argv[1][i], ush);\n    }\n    if (pr == 0) {\n        ush->exit_status = 1;\n        return 1;\n    }\n    mx_print_cont(pr->name, pr->index);\n    kill(pr->pid, SIGCONT);\n    return 0;\n}\n\nstatic void fg_wait(int status, pid_t ch_pr, t_ush *ush) {\n    if (MX_WIFSIG(status)) {\n        if (MX_WTERMSIG(status) == SIGSEGV)\n            mx_segfault();\n        else if (MX_WTERMSIG(status) == SIGINT) {\n            mx_del_pid_process(ush, ch_pr);\n            ush->last_status = 130;\n        }\n        else {\n            char **str = mx_get_name(ush, ch_pr);\n            mx_print_susp(str);\n        }\n    }\n}\n\nvoid mx_fg(char **argv, t_ush *ush) {\n    pid_t ch_pr = 0;\n    int status = 0;\n\n    if (ush->processes) {\n        if (fg_continue(argv, ush) == 0) {\n            ch_pr = waitpid(-1, &status, WUNTRACED);\n            if (!MX_WIFEXIT(status))\n                fg_wait(status, ch_pr, ush);\n            else {\n                mx_del_pid_process(ush, ch_pr);\n                ush->last_status = MX_EXSTATUS(status);\n            }\n        }\n    }\n    else\n        mx_printerr(\"fg: no current job\\n\");\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/builtins/mx_fg.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/builtins/mx_fg.c	(date 1592817913000)
@@ -1,20 +1,20 @@
 #include "ush.h"
 
-static t_process* get_process(int n, char *str, t_ush *ush) {
+static t_processes* get_process(int n, char *str, t_ush *ush) {
     t_list *tmp = ush->processes;
 
     if (n != -1) {
         while (tmp) {
-            if (((t_process*)tmp->data)->index == n)
-                return ((t_process*)tmp->data);
+            if (((t_processes*)tmp->data)->index == n)
+                return ((t_processes*)tmp->data);
             tmp = tmp->next;
         }
         fprintf(stderr, "fg: job not found: %s\n", str);
     }
     else {
         while (tmp) {
-            if (mx_is_str_starts(((t_process*)tmp->data)->name[0], str))
-                return ((t_process*)tmp->data);
+            if (mx_is_str_starts(((t_processes*)tmp->data)->name[0], str))
+                return ((t_processes*)tmp->data);
             tmp = tmp->next;
         }
         fprintf(stderr, "fg: job not found: %s\n", str);
@@ -35,7 +35,7 @@
 }
 
 static int fg_continue(char **argv, t_ush *ush) {
-    t_process *pr = (t_process*)ush->processes->data;
+    t_processes *pr = (t_processes*)ush->processes->data;
     int i = 0;
 
     if (argv[1] == 0) {
Index: src/builtins/mx_jobs.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nstatic void print_row(t_list *tmp, char c) {\n    char *name = mx_arrstr_to_str(((t_process*)tmp->data)->name);\n\n    printf(\"[%d] %c suspended %s\\n\", ((t_process*)tmp->data)->index, c,\n        name);\n    free(name);\n}\n\nvoid mx_jobs(t_ush *ush) {\n    t_list *tmp = ush->processes;\n    char c = 0;\n    int i = -1;\n\n    if (tmp == 0)\n        printf(\"fg: no current job\\n\");\n    while (tmp) {\n        \n        if (++i == 0)\n            c = '+';\n        else if (i == 1)\n            c = '-';\n        else \n            c = ' ';\n        print_row(tmp, c);\n        tmp = tmp->next;\n    }\n    ush->last_status = 0;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/builtins/mx_jobs.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/builtins/mx_jobs.c	(date 1592817913000)
@@ -1,9 +1,9 @@
 #include "ush.h"
 
 static void print_row(t_list *tmp, char c) {
-    char *name = mx_arrstr_to_str(((t_process*)tmp->data)->name);
+    char *name = mx_arrstr_to_str(((t_processes*)tmp->data)->name);
 
-    printf("[%d] %c suspended %s\n", ((t_process*)tmp->data)->index, c,
+    printf("[%d] %c suspended %s\n", ((t_processes*)tmp->data)->index, c,
         name);
     free(name);
 }
Index: src/signals/mx_read_keyboard.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nunsigned int mx_read_keyboard(t_ush *ush) {\n    unsigned int ch = 0;\n\n    if ((ch = mx_getchar()) == 0) {\n        mx_printerr(\"u$h: some troubeles with input!\\n\");\n        exit(2);\n    }\n    if (ush->input->if_  == 9 && ch != 9)\n        mx_del_strarr(&(ush->input->comand_tab));\n    return ch;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/signals/mx_read_keyboard.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/signals/mx_read_keyboard.c	(date 1592817913000)
@@ -7,7 +7,7 @@
         mx_printerr("u$h: some troubeles with input!\n");
         exit(2);
     }
-    if (ush->input->if_  == 9 && ch != 9)
+    if (ush->input->symbol  == 9 && ch != 9)
         mx_del_strarr(&(ush->input->comand_tab));
     return ch;
 }
Index: src/signals/mx_ctrl_r.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nstatic unsigned int mx_read_keyb_and_prinitng(t_ush *ush, int index,\n                                                  int i, char *temp) {\n    unsigned int ch = 0;\n\n    if (index != MX_MAX_COMAND + 1)\n        mx_terminal_out(MX_USH, mx_strlen(MX_COMMAND[index]) + 1, 0,\n                           MX_COMMAND[index]);\n    else\n        mx_terminal_out(MX_USH, 1, 0, \"\");\n    mx_printstr(\"\\n\");\n    mx_terminal_out(MX_SEARCH, i, 0, temp);\n    ch = mx_getchar();\n    mx_clean_terminal(MX_SEARCH, i, 0, temp);\n    mx_print_esc(\"1A\");\n    return ch;\n}\n\nstatic int search_comand(t_ush *ush, int index, char *temp) {\n    int index_comand = MX_MAX_COMAND + 1;\n    int str_len_comand = 0;\n\n    if (index != MX_MAX_COMAND + 1) {\n        str_len_comand = mx_strlen(MX_COMMAND[index]) + 1;\n        mx_clean_terminal(MX_USH, str_len_comand, 0, MX_COMMAND[index]);\n    }\n    else\n        mx_clean_terminal(MX_USH, 1, 0, \"\");\n    for (int y = 0; index_comand == MX_MAX_COMAND + 1 && MX_COMMAND[y]; y++)\n        if (mx_strstr(MX_COMMAND[y], temp) != 0)\n            index_comand = y;\n    return index_comand;\n}\n\nvoid mx_ctrl_r(t_ush *ush) {\n    unsigned int ch = 0; \n    char *temp = mx_strnew(0);\n    int i = 1;\n    bool check = 1;\n    int index = MX_MAX_COMAND + 1;\n\n    while (check) {\n        ch = mx_read_keyb_and_prinitng(ush, index, i, temp);\n        if (ch > 31 && ch < 128)\n            mx_one_symbol(&temp, ch, &i, 0);\n        else\n            check = 0;\n        index = search_comand(ush, index, temp);\n    }\n    if (index != MX_MAX_COMAND + 1) {\n        MX_ID = index;\n        MX_STR_POS = 0;\n        MX_STR_LEN = mx_strlen(MX_STR) + 1;\n    }\n    mx_strdel(&temp);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/signals/mx_ctrl_r.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/signals/mx_ctrl_r.c	(date 1592817913000)
@@ -4,9 +4,9 @@
                                                   int i, char *temp) {
     unsigned int ch = 0;
 
-    if (index != MX_MAX_COMAND + 1)
-        mx_terminal_out(MX_USH, mx_strlen(MX_COMMAND[index]) + 1, 0,
-                           MX_COMMAND[index]);
+    if (index != ush->input->fullcom + 1)
+        mx_terminal_out(MX_USH, mx_strlen(ush->input->comands[index]) + 1, 0,
+                           ush->input->comands[index]);
     else
         mx_terminal_out(MX_USH, 1, 0, "");
     mx_printstr("\n");
@@ -18,17 +18,17 @@
 }
 
 static int search_comand(t_ush *ush, int index, char *temp) {
-    int index_comand = MX_MAX_COMAND + 1;
+    int index_comand = ush->input->fullcom + 1;
     int str_len_comand = 0;
 
-    if (index != MX_MAX_COMAND + 1) {
-        str_len_comand = mx_strlen(MX_COMMAND[index]) + 1;
-        mx_clean_terminal(MX_USH, str_len_comand, 0, MX_COMMAND[index]);
+    if (index != ush->input->fullcom + 1) {
+        str_len_comand = mx_strlen(ush->input->comands[index]) + 1;
+        mx_clean_terminal(MX_USH, str_len_comand, 0, ush->input->comands[index]);
     }
     else
         mx_clean_terminal(MX_USH, 1, 0, "");
-    for (int y = 0; index_comand == MX_MAX_COMAND + 1 && MX_COMMAND[y]; y++)
-        if (mx_strstr(MX_COMMAND[y], temp) != 0)
+    for (int y = 0; index_comand == ush->input->fullcom + 1 && ush->input->comands[y]; y++)
+        if (mx_strstr(ush->input->comands[y], temp) != 0)
             index_comand = y;
     return index_comand;
 }
@@ -38,7 +38,7 @@
     char *temp = mx_strnew(0);
     int i = 1;
     bool check = 1;
-    int index = MX_MAX_COMAND + 1;
+    int index = ush->input->fullcom + 1;
 
     while (check) {
         ch = mx_read_keyb_and_prinitng(ush, index, i, temp);
@@ -48,10 +48,10 @@
             check = 0;
         index = search_comand(ush, index, temp);
     }
-    if (index != MX_MAX_COMAND + 1) {
-        MX_ID = index;
-        MX_STR_POS = 0;
-        MX_STR_LEN = mx_strlen(MX_STR) + 1;
+    if (index != ush->input->fullcom + 1) {
+        ush->input->id = index;
+        ush->input->endpoint = 0;
+        ush->input->inplen = mx_strlen(ush->input->comands[ush->input->id]) + 1;
     }
     mx_strdel(&temp);
 }
Index: src/builtins/mx_add_process.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nstatic int get_index(t_list *process) {\n    t_list *tmp = process;\n    int max = 0;\n\n    if (tmp == 0)\n        return 0;\n    max = ((t_process*)tmp->data)->index;\n    while (tmp) {\n        if (max < ((t_process*)tmp->data)->index) {\n            max = ((t_process*)tmp->data)->index;\n        }\n        tmp = tmp->next;\n    }\n    return max;\n}\n\nstatic bool is_exist(t_list *process, pid_t pid) {\n    t_list *tmp = process;\n\n    while (tmp) {\n        if (((t_process*)process->data)->pid == pid)\n            return true;\n        tmp = tmp->next;\n    }\n    return false;\n}\n\nint mx_add_process(t_list **processes, pid_t pid, char **name) {\n    int max_index = get_index(*processes);\n    t_process *pr = 0;\n\n    if (is_exist(*processes, pid))\n        return -1;\n    pr = (t_process*)malloc(sizeof(t_process));\n    pr->index = max_index + 1;\n    pr->pid = pid;\n    pr->name = mx_dupstrarr(name);\n    mx_push_front(processes, pr);\n    return max_index + 1;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/builtins/mx_add_process.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/builtins/mx_add_process.c	(date 1592817913000)
@@ -6,10 +6,10 @@
 
     if (tmp == 0)
         return 0;
-    max = ((t_process*)tmp->data)->index;
+    max = ((t_processes*)tmp->data)->index;
     while (tmp) {
-        if (max < ((t_process*)tmp->data)->index) {
-            max = ((t_process*)tmp->data)->index;
+        if (max < ((t_processes*)tmp->data)->index) {
+            max = ((t_processes*)tmp->data)->index;
         }
         tmp = tmp->next;
     }
@@ -20,7 +20,7 @@
     t_list *tmp = process;
 
     while (tmp) {
-        if (((t_process*)process->data)->pid == pid)
+        if (((t_processes*)process->data)->pid == pid)
             return true;
         tmp = tmp->next;
     }
@@ -29,11 +29,11 @@
 
 int mx_add_process(t_list **processes, pid_t pid, char **name) {
     int max_index = get_index(*processes);
-    t_process *pr = 0;
+    t_processes *pr = 0;
 
     if (is_exist(*processes, pid))
         return -1;
-    pr = (t_process*)malloc(sizeof(t_process));
+    pr = (t_processes*)malloc(sizeof(t_processes));
     pr->index = max_index + 1;
     pr->pid = pid;
     pr->name = mx_dupstrarr(name);
Index: src/utils/mx_not_ascii.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nstatic void left_right(char *chars, t_ush *ush) {\n    unsigned char check;\n\n    if (chars[2] == 67) { // RIGHT\n        mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);\n        check = (unsigned char)MX_STR[MX_STR_LEN - MX_STR_POS];\n        while (check >> 6 == 2) {\n            MX_STR_POS--;\n            check = (unsigned char)MX_STR[MX_STR_LEN - MX_STR_POS];\n        }\n        (MX_STR_POS)--;\n    }\n    else { // LEFT\n        mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);\n        check = (unsigned char)MX_STR[MX_STR_LEN - MX_STR_POS - 2];\n        while (check >> 6 == 2) {\n            (MX_STR_POS)++;\n            check = (unsigned char)MX_STR[MX_STR_LEN - MX_STR_POS - 2];\n        }\n        (MX_STR_POS)++;\n    }\n}\n\nstatic void up_down(char *chars, t_ush *ush){\n    if (chars[2] == 65) { // UP\n        if (MX_ID != MX_MAX_COMAND) {\n            mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);\n            (MX_ID)++;\n            MX_STR_POS = 0;\n            MX_STR_LEN = mx_strlen(MX_STR) + 1;\n        }\n        else \n            chars[2] = 10;\n    }\n    else if (chars[2] == 66) { //DOWN\n        if (MX_ID != 0) {\n            mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);\n            (MX_ID)--;\n            MX_STR_POS = 0;\n            MX_STR_LEN = mx_strlen(MX_STR) + 1;\n        }\n        else \n            chars[2] = 10;\n    }\n}\n\nstatic void home_end(char *chars, t_ush *ush) {\n    if (chars[2] == 70) { // position 0\n        if (MX_STR_POS != 0) {\n            mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);\n            MX_STR_POS = 0;\n        }\n        else \n            chars[2] = 10;\n    }\n    else if (chars[2] == 72) { // position end\n        if (MX_STR_POS != MX_STR_LEN - 1) {\n            mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);\n            MX_STR_POS = MX_STR_LEN - 1;\n        }\n        else \n            chars[2] = 10;\n    }\n    else \n        mx_printstr(\"/n/nEROOR!! DUBLE_COMAND\\n\\n\");\n}\n\nstatic void page_u_Page_d(char *chars, t_ush *ush) {\n    if (chars[2] == 53) { // PageUP\n        if (MX_ID != MX_MAX_COMAND) {\n            mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);\n            MX_STR_POS = 0;\n            MX_STR_LEN = mx_strlen(ush->input->comands[MX_MAX_COMAND]) + 1;\n            MX_ID = MX_MAX_COMAND;\n        }\n        else\n            chars[2] = 10;\n    }\n    else if (chars[2] == 54) { //PageDown\n        if (MX_ID != 0) {\n            mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);\n            MX_STR_LEN = mx_strlen(ush->input->comands[0]) + 1;\n            MX_STR_POS = 0;\n            MX_ID = 0;\n        }\n        else\n            chars[2] = 10;\n    }\n}\n\nvoid mx_not_ascii(char *chars, t_ush *ush) {\n    if (chars[3] == 0 && (chars[2] == 65 || chars[2] == 66)) {\n        up_down(chars, ush);\n    }\n    else if (chars[3] == 0 && (chars[2] == 70 || chars[2] == 72)) {\n        home_end(chars, ush);\n    }\n    else if (chars[3] == 0 && chars[2] == 68 && MX_STR_LEN - 1 > MX_STR_POS) {\n        left_right(chars, ush);\n    }\n    else if (chars[3] == 0 && chars[2] == 67 && 0 < MX_STR_POS) {\n        left_right(chars, ush);\n    }\n    else if (chars[3] == 126 && (chars[2] == 53 || chars[2] == 54)) {\n        page_u_Page_d(chars, ush);\n    }\n    else if (chars[3] == 126 && chars[2] == 51 && MX_STR_POS != 0) {\n        mx_key_delite(ush);\n    }\n    else\n        chars[2] = 10;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/utils/mx_not_ascii.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/utils/mx_not_ascii.c	(date 1592817913000)
@@ -4,42 +4,42 @@
     unsigned char check;
 
     if (chars[2] == 67) { // RIGHT
-        mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);
-        check = (unsigned char)MX_STR[MX_STR_LEN - MX_STR_POS];
+        mx_clean_terminal(MX_USH, ush->input->inplen, ush->input->endpoint, ush->input->comands[ush->input->id]);
+        check = (unsigned char)ush->input->comands[ush->input->id][ush->input->inplen - ush->input->endpoint];
         while (check >> 6 == 2) {
-            MX_STR_POS--;
-            check = (unsigned char)MX_STR[MX_STR_LEN - MX_STR_POS];
+            ush->input->endpoint--;
+            check = (unsigned char)ush->input->comands[ush->input->id][ush->input->inplen - ush->input->endpoint];
         }
-        (MX_STR_POS)--;
+        (ush->input->endpoint)--;
     }
     else { // LEFT
-        mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);
-        check = (unsigned char)MX_STR[MX_STR_LEN - MX_STR_POS - 2];
+        mx_clean_terminal(MX_USH, ush->input->inplen, ush->input->endpoint, ush->input->comands[ush->input->id]);
+        check = (unsigned char)ush->input->comands[ush->input->id][ush->input->inplen - ush->input->endpoint - 2];
         while (check >> 6 == 2) {
-            (MX_STR_POS)++;
-            check = (unsigned char)MX_STR[MX_STR_LEN - MX_STR_POS - 2];
+            (ush->input->endpoint)++;
+            check = (unsigned char)ush->input->comands[ush->input->id][ush->input->inplen - ush->input->endpoint - 2];
         }
-        (MX_STR_POS)++;
+        (ush->input->endpoint)++;
     }
 }
 
 static void up_down(char *chars, t_ush *ush){
     if (chars[2] == 65) { // UP
-        if (MX_ID != MX_MAX_COMAND) {
-            mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);
-            (MX_ID)++;
-            MX_STR_POS = 0;
-            MX_STR_LEN = mx_strlen(MX_STR) + 1;
+        if (ush->input->id != ush->input->fullcom) {
+            mx_clean_terminal(MX_USH, ush->input->inplen, ush->input->endpoint, ush->input->comands[ush->input->id]);
+            (ush->input->id)++;
+            ush->input->endpoint = 0;
+            ush->input->inplen = mx_strlen(ush->input->comands[ush->input->id]) + 1;
         }
         else 
             chars[2] = 10;
     }
     else if (chars[2] == 66) { //DOWN
-        if (MX_ID != 0) {
-            mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);
-            (MX_ID)--;
-            MX_STR_POS = 0;
-            MX_STR_LEN = mx_strlen(MX_STR) + 1;
+        if (ush->input->id != 0) {
+            mx_clean_terminal(MX_USH, ush->input->inplen, ush->input->endpoint, ush->input->comands[ush->input->id]);
+            (ush->input->id)--;
+            ush->input->endpoint = 0;
+            ush->input->inplen = mx_strlen(ush->input->comands[ush->input->id]) + 1;
         }
         else 
             chars[2] = 10;
@@ -48,17 +48,17 @@
 
 static void home_end(char *chars, t_ush *ush) {
     if (chars[2] == 70) { // position 0
-        if (MX_STR_POS != 0) {
-            mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);
-            MX_STR_POS = 0;
+        if (ush->input->endpoint != 0) {
+            mx_clean_terminal(MX_USH, ush->input->inplen, ush->input->endpoint, ush->input->comands[ush->input->id]);
+            ush->input->endpoint = 0;
         }
         else 
             chars[2] = 10;
     }
     else if (chars[2] == 72) { // position end
-        if (MX_STR_POS != MX_STR_LEN - 1) {
-            mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);
-            MX_STR_POS = MX_STR_LEN - 1;
+        if (ush->input->endpoint != ush->input->inplen - 1) {
+            mx_clean_terminal(MX_USH, ush->input->inplen, ush->input->endpoint, ush->input->comands[ush->input->id]);
+            ush->input->endpoint = ush->input->inplen - 1;
         }
         else 
             chars[2] = 10;
@@ -69,21 +69,21 @@
 
 static void page_u_Page_d(char *chars, t_ush *ush) {
     if (chars[2] == 53) { // PageUP
-        if (MX_ID != MX_MAX_COMAND) {
-            mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);
-            MX_STR_POS = 0;
-            MX_STR_LEN = mx_strlen(ush->input->comands[MX_MAX_COMAND]) + 1;
-            MX_ID = MX_MAX_COMAND;
+        if (ush->input->id != ush->input->fullcom) {
+            mx_clean_terminal(MX_USH, ush->input->inplen, ush->input->endpoint, ush->input->comands[ush->input->id]);
+            ush->input->endpoint = 0;
+            ush->input->inplen = mx_strlen(ush->input->comands[ush->input->fullcom]) + 1;
+            ush->input->id = ush->input->fullcom;
         }
         else
             chars[2] = 10;
     }
     else if (chars[2] == 54) { //PageDown
-        if (MX_ID != 0) {
-            mx_clean_terminal(MX_USH, MX_STR_LEN, MX_STR_POS, MX_STR);
-            MX_STR_LEN = mx_strlen(ush->input->comands[0]) + 1;
-            MX_STR_POS = 0;
-            MX_ID = 0;
+        if (ush->input->id != 0) {
+            mx_clean_terminal(MX_USH, ush->input->inplen, ush->input->endpoint, ush->input->comands[ush->input->id]);
+            ush->input->inplen = mx_strlen(ush->input->comands[0]) + 1;
+            ush->input->endpoint = 0;
+            ush->input->id = 0;
         }
         else
             chars[2] = 10;
@@ -97,16 +97,16 @@
     else if (chars[3] == 0 && (chars[2] == 70 || chars[2] == 72)) {
         home_end(chars, ush);
     }
-    else if (chars[3] == 0 && chars[2] == 68 && MX_STR_LEN - 1 > MX_STR_POS) {
+    else if (chars[3] == 0 && chars[2] == 68 && ush->input->inplen - 1 > ush->input->endpoint) {
         left_right(chars, ush);
     }
-    else if (chars[3] == 0 && chars[2] == 67 && 0 < MX_STR_POS) {
+    else if (chars[3] == 0 && chars[2] == 67 && 0 < ush->input->endpoint) {
         left_right(chars, ush);
     }
     else if (chars[3] == 126 && (chars[2] == 53 || chars[2] == 54)) {
         page_u_Page_d(chars, ush);
     }
-    else if (chars[3] == 126 && chars[2] == 51 && MX_STR_POS != 0) {
+    else if (chars[3] == 126 && chars[2] == 51 && ush->input->endpoint != 0) {
         mx_key_delite(ush);
     }
     else
Index: src/exec/mx_exec_token.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nstatic void del_desc(char operator_status, int *fds) {\n    if ((operator_status & OP_PIPE_W) || (operator_status & OP_MORE))\n        close(fds[1]);\n    if (operator_status & OP_PIPE_R)\n        close(fds[0]);\n}\n\nstatic void child(t_token *token, char operator_status, int *fds) {\n    if (operator_status & 23) {\n            dup2(fds[1], 1);\n            dup2(fds[0], 0);\n        }\n        mx_execute_proces(token);\n}\n\nint exec_token(t_token *token, int *fds, char operator_status, t_ush *ush) {\n    int exit_status = 0;\n    pid_t pid = fork();\n\n    if (pid == 0)\n        child(token, operator_status, fds);\n    else {\n        del_desc(operator_status, fds);\n        if (!(operator_status & OP_AMP)) {\n            mx_wait_process(ush, token->value);\n            return exit_status;\n        }\n        else {\n            if (mx_add_process(&(ush->processes), pid, token->value) != -1)\n                printf(\"Process [%d] created\\n\", pid);\n            printf(\"pr = %d\\n\", ((t_process*)ush->processes->data)->pid);\n        }\n    }\n    return 1;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/exec/mx_exec_token.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/exec/mx_exec_token.c	(date 1592817913000)
@@ -30,7 +30,7 @@
         else {
             if (mx_add_process(&(ush->processes), pid, token->value) != -1)
                 printf("Process [%d] created\n", pid);
-            printf("pr = %d\n", ((t_process*)ush->processes->data)->pid);
+            printf("pr = %d\n", ((t_processes*)ush->processes->data)->pid);
         }
     }
     return 1;
Index: src/builtins/mx_close_all_pr.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nvoid mx_close_all_pr(t_ush *ush) {\n    t_list *tmp = ush->processes;\n\n    while (tmp) {\n        if (kill(((t_process*)tmp->data)->pid, SIGKILL) == 0)\n            printf(\"Process [%d] killed\\n\", ((t_process*)tmp->data)->pid);\n        tmp = tmp->next;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/builtins/mx_close_all_pr.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/builtins/mx_close_all_pr.c	(date 1592817913000)
@@ -4,8 +4,8 @@
     t_list *tmp = ush->processes;
 
     while (tmp) {
-        if (kill(((t_process*)tmp->data)->pid, SIGKILL) == 0)
-            printf("Process [%d] killed\n", ((t_process*)tmp->data)->pid);
+        if (kill(((t_processes*)tmp->data)->pid, SIGKILL) == 0)
+            printf("Process [%d] killed\n", ((t_processes*)tmp->data)->pid);
         tmp = tmp->next;
     }
 }
Index: src/builtins/mx_key_tab.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nstatic bool cmp_str_min_max(void *str1, void *str2) {\n    if (mx_strcmp(str1, str2) > 0)\n        return 1;\n    else \n        return 0;\n}\n\nstatic char **many_comand_in_list(char *path, char **str, t_ush *ush,\n                                  t_list *list_comand) {\n    int number_comand = 0;\n    char **creat_list_comands = NULL;\n    int temp = 0;\n    int size_list = mx_list_size(list_comand) + 1;\n    char *name_comand = 0;\n\n    mx_clean_space_in_term(\"\", ush, *str);\n    mx_print_tab_comands(list_comand);\n    creat_list_comands = (char **)malloc(size_list * sizeof(char *));\n    for (temp = mx_strlen(path) - 1; temp != 0 && path[temp] != '/'; temp--);\n    temp = mx_strlen(&path[temp]);\n    while (list_comand) {\n        name_comand = list_comand->data;\n        creat_list_comands[number_comand++] = mx_strdup(&name_comand[temp - 1]);\n        mx_pop_front(&list_comand);\n    }\n    creat_list_comands[number_comand++] = NULL;\n    return creat_list_comands;\n}\n\nstatic void one_comand_in_list(t_ush *ush, t_list *list_comand, char **str,\n                               char *path) {\n    int len_comand = mx_strlen(path) - 1;\n\n    for (; len_comand != 0 && path[len_comand] != '/';)\n        len_comand--;\n        len_comand = mx_strlen(&path[len_comand]);\n        path = list_comand->data;\n        for (int i = len_comand - 1; path[i]; i++)\n            mx_one_symbol(str, path[i], &(MX_STR_LEN), MX_STR_POS);\n        if (MX_STR_POS != 0) {\n            mx_one_symbol(str, ' ', &(MX_STR_LEN), MX_STR_POS);\n            (MX_STR_POS)++;\n        }\n        mx_pop_front_free_data(&list_comand);\n}\n\nchar **mx_key_tab(char *parsing, char **str, t_ush *ush) {\n    char *path = mx_mini_parser_tab(parsing, ush);\n    t_list *list_comand = 0;\n    char **creat_list_comand = NULL;\n    int comand_len = 0;\n\n    mx_read_comand(path, &list_comand);\n    list_comand = mx_sort_list(list_comand, &cmp_str_min_max);\n    if (!((comand_len = mx_list_size(list_comand)) == 0 || comand_len == 1))\n        creat_list_comand = many_comand_in_list(path, str, ush, list_comand);\n    else if (comand_len == 1)\n        one_comand_in_list(ush, list_comand, str, path);\n    else\n        write(1,\"\\a\", 1);\n    mx_strdel(&path);\n    mx_strdel(&parsing);\n    return creat_list_comand;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/builtins/mx_key_tab.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/builtins/mx_key_tab.c	(date 1592817913000)
@@ -38,10 +38,10 @@
         len_comand = mx_strlen(&path[len_comand]);
         path = list_comand->data;
         for (int i = len_comand - 1; path[i]; i++)
-            mx_one_symbol(str, path[i], &(MX_STR_LEN), MX_STR_POS);
-        if (MX_STR_POS != 0) {
-            mx_one_symbol(str, ' ', &(MX_STR_LEN), MX_STR_POS);
-            (MX_STR_POS)++;
+            mx_one_symbol(str, path[i], &(ush->input->inplen), ush->input->endpoint);
+        if (ush->input->endpoint != 0) {
+            mx_one_symbol(str, ' ', &(ush->input->inplen), ush->input->endpoint);
+            (ush->input->endpoint)++;
         }
         mx_pop_front_free_data(&list_comand);
 }
Index: src/parsers/mx_mini_parser_tab.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"ush.h\"\n\nstatic bool name_comand(char temp) {\n    char check = temp >> 7;\n\n    if ((temp > 47 && temp < 58) || (temp > 64 && temp <91) || temp == '~')\n        return 1;\n    if ((temp > 96 && temp < 123) || temp == 46 || temp == '/' || temp == '.')\n        return 1;\n    if (temp == '+' || temp == '-' || temp == '_')\n        return 1;\n    if (check != 0)\n        return 1;\n    else\n        return 0;\n}\n\nstatic char *create_str_comand(char *parsing) {\n    int str_len;\n    char *temp_str = 0;\n\n    if (parsing == 0)\n        return mx_strnew(0);\n    str_len = mx_strlen(parsing) - 1;\n    while (str_len > -1 && name_comand(parsing[str_len]))\n        str_len--;\n    if (str_len == -1)\n        temp_str =  mx_strjoin(\"\\r\", parsing);\n    else\n        temp_str = mx_strdup(&parsing[str_len]);\n    while (str_len > -1 && parsing[str_len] == ' ')\n        str_len--;\n    if (str_len == -1)\n        temp_str[0] = '\\r';\n    else\n        temp_str[0] = parsing[str_len];\n    return temp_str;\n}\n\nchar *mx_mini_parser_tab(char *parsing, t_ush *ush) {\n    char *tem_str = create_str_comand(parsing);\n    int pos = 0;\n    char if_comand = 0;\n    char *temp = 0;\n\n    if (mx_strstr(tem_str, \"/\"))\n        tem_str[0] = '1';\n    if (tem_str[0] != 0 && tem_str[1] == '~') {\n        pos = 0;\n        temp = mx_strdup(&tem_str[1]);\n        if_comand = tem_str[0];\n        mx_strdel(&tem_str);\n        mx_home(&temp, &pos, ush);\n        tem_str = mx_strjoin(\"\\r\", temp);\n        mx_strdel(&temp);\n        tem_str[0] = if_comand;\n    }\n    return tem_str;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/parsers/mx_mini_parser_tab.c	(revision 58849f6ca8aba124671160a25a42b755f5823a55)
+++ src/parsers/mx_mini_parser_tab.c	(date 1592817913000)
@@ -16,24 +16,24 @@
 }
 
 static char *create_str_comand(char *parsing) {
-    int str_len;
+    int inplen;
     char *temp_str = 0;
 
     if (parsing == 0)
         return mx_strnew(0);
-    str_len = mx_strlen(parsing) - 1;
-    while (str_len > -1 && name_comand(parsing[str_len]))
-        str_len--;
-    if (str_len == -1)
+    inplen = mx_strlen(parsing) - 1;
+    while (inplen > -1 && name_comand(parsing[inplen]))
+        inplen--;
+    if (inplen == -1)
         temp_str =  mx_strjoin("\r", parsing);
     else
-        temp_str = mx_strdup(&parsing[str_len]);
-    while (str_len > -1 && parsing[str_len] == ' ')
-        str_len--;
-    if (str_len == -1)
+        temp_str = mx_strdup(&parsing[inplen]);
+    while (inplen > -1 && parsing[inplen] == ' ')
+        inplen--;
+    if (inplen == -1)
         temp_str[0] = '\r';
     else
-        temp_str[0] = parsing[str_len];
+        temp_str[0] = parsing[inplen];
     return temp_str;
 }
 
